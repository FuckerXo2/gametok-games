<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Stack Ball</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      touch-action: none; 
      background: #1a1a2e;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    canvas { display: block; }
    
    /* UI Layer */
    #ui {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      pointer-events: none;
      z-index: 10;
    }
    
    /* Level Progress Bar (right side) */
    #levelProgress {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }
    #levelProgress .level {
      font-size: 14px;
      font-weight: 700;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }
    #progressTrack {
      width: 8px;
      height: 180px;
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
      position: relative;
    }
    #progressFill {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 0%;
      background: white;
      border-radius: 4px;
      transition: height 0.2s ease-out;
    }
    
    /* Invincibility Indicator (left side) */
    #invincibilityIndicator {
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      width: 10px;
      height: 120px;
      background: rgba(255,255,255,0.15);
      border-radius: 5px;
      opacity: 0;
      transition: opacity 0.3s;
    }
    #invincibilityIndicator.visible { opacity: 1; }
    #invincibilityFill {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 0%;
      background: white;
      border-radius: 5px;
      transition: height 0.1s, background 0.3s;
    }
    #invincibilityIndicator.invincible #invincibilityFill {
      background: #FF4444;
    }
    
    /* Score Display */
    #scoreDisplay {
      position: absolute;
      top: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 64px;
      font-weight: 900;
      color: white;
      text-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    
    /* Start Screen */
    #startScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
      color: white;
      pointer-events: auto;
    }
    #startScreen h1 {
      font-size: 48px;
      font-weight: 900;
      margin-bottom: 8px;
      text-shadow: 0 4px 30px rgba(0,0,0,0.3);
    }
    #startScreen p {
      font-size: 16px;
      opacity: 0.8;
      margin-bottom: 50px;
    }
    #startScreen .btn {
      font-size: 18px;
      padding: 18px 60px;
      background: white;
      border-radius: 50px;
      font-weight: 800;
      color: #764ba2;
      box-shadow: 0 15px 40px rgba(0,0,0,0.3);
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    /* Game Over / Win Screen */
    #endScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.85);
      color: white;
      pointer-events: auto;
    }
    #endScreen h2 {
      font-size: 28px;
      font-weight: 700;
      margin-bottom: 10px;
    }
    #endScreen .finalScore {
      font-size: 80px;
      font-weight: 900;
      margin-bottom: 8px;
    }
    #endScreen .bestScore {
      font-size: 16px;
      opacity: 0.6;
      margin-bottom: 50px;
    }
    #endScreen .btn {
      font-size: 18px;
      padding: 18px 60px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-radius: 50px;
      font-weight: 800;
      color: white;
      box-shadow: 0 15px 40px rgba(102,126,234,0.4);
    }
    
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="scoreDisplay">0</div>
    
    <div id="levelProgress">
      <span class="level" id="nextLevel">2</span>
      <div id="progressTrack">
        <div id="progressFill"></div>
      </div>
      <span class="level" id="currentLevel">1</span>
    </div>
    
    <div id="invincibilityIndicator">
      <div id="invincibilityFill"></div>
    </div>
    
    <div id="startScreen">
      <h1>STACK BALL</h1>
      <p>Hold to smash through platforms</p>
      <div class="btn">TAP TO START</div>
    </div>
    
    <div id="endScreen">
      <h2 id="endTitle">GAME OVER</h2>
      <div class="finalScore" id="finalScore">0</div>
      <div class="bestScore" id="bestScore">BEST: 0</div>
      <div class="btn">TAP TO RETRY</div>
    </div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // ============================================
    // STACK BALL - HTML5 REPLICA OF UNITY VERSION
    // ============================================
    
    // === CONFIGURATION (from Unity SerializeFields) ===
    const CONFIG = {
      // PlatformGenerator settings
      platformCount: 50,
      platformOffsetAngle: 2, // degrees
      platformOffsetHeight: 0.4,
      minSamePlatforms: 5,
      maxSamePlatforms: 40,
      platformSafeParts: 2,
      
      // Platform settings
      platformRadius: 3.0,
      platformHoleRadius: 0.45,
      platformHeight: 0.5,
      platformSegments: 8,
      platformDestroyDuration: 1.0,
      platformThrowOffsetX: 8,
      platformThrowOffsetY: 13,
      
      // Ball settings
      ballRadius: 0.45,
      jumpPower: 8,
      moveSpeed: 15,
      gravity: 20,
      
      // Camera settings
      cameraTrackOffset: { x: 0, y: 3, z: -8.3 },
      cameraStartOffset: { x: 0, y: 1.5, z: -8.3 },
      cameraTrackDelay: 0.25,
      
      // Invincibility settings
      secondsPerPlatform: 0.15,
      invincibleSeconds: 3,
      platformsToEnableIndicator: 10,
      secondsToEnableInvincible: 4,
      
      // Colors - gradient from Unity
      gradientColors: [
        { pos: 0.0, r: 255, g: 107, b: 107 },  // Red-pink
        { pos: 0.25, r: 255, g: 230, b: 109 }, // Yellow
        { pos: 0.5, r: 78, g: 205, b: 196 },   // Teal
        { pos: 0.75, r: 187, g: 143, b: 206 }, // Purple
        { pos: 1.0, r: 255, g: 139, b: 148 }   // Pink
      ]
    };
    
    // === GAME STATE ===
    let scene, camera, renderer;
    let ball, ballVelocity = 0;
    let platforms = [];
    let particles = [];
    let footprints = [];
    let trailParticles = [];
    
    let gameState = 'start'; // 'start', 'playing', 'ended'
    let isPressed = false;
    let score = 0;
    let bestScore = parseInt(localStorage.getItem('stackball_best') || '0');
    let level = 1;
    let platformsDestroyed = 0;
    
    // Invincibility state
    let isInvincible = false;
    let invincibilityTimer = 0;
    let invincibilityBuildUp = 0;
    let platformsForInvincibility = 0;
    
    // Camera state
    let cameraTargetY;
    let cameraVelocity = 0;
    
    // Audio
    let audioCtx;
    
    // DOM elements
    const scoreDisplay = document.getElementById('scoreDisplay');
    const progressFill = document.getElementById('progressFill');
    const invincibilityIndicator = document.getElementById('invincibilityIndicator');
    const invincibilityFill = document.getElementById('invincibilityFill');
    const startScreen = document.getElementById('startScreen');
    const endScreen = document.getElementById('endScreen');
    const endTitle = document.getElementById('endTitle');
    const finalScoreEl = document.getElementById('finalScore');
    const bestScoreEl = document.getElementById('bestScore');
    
    // === UTILITY FUNCTIONS ===
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }
    
    function lerpColor(c1, c2, t) {
      return {
        r: Math.round(lerp(c1.r, c2.r, t)),
        g: Math.round(lerp(c1.g, c2.g, t)),
        b: Math.round(lerp(c1.b, c2.b, t))
      };
    }
    
    function getGradientColor(t) {
      const colors = CONFIG.gradientColors;
      t = Math.max(0, Math.min(1, t));
      
      for (let i = 0; i < colors.length - 1; i++) {
        if (t >= colors[i].pos && t <= colors[i + 1].pos) {
          const localT = (t - colors[i].pos) / (colors[i + 1].pos - colors[i].pos);
          return lerpColor(colors[i], colors[i + 1], localT);
        }
      }
      return colors[colors.length - 1];
    }
    
    function colorToHex(c) {
      return (c.r << 16) | (c.g << 8) | c.b;
    }
    
    function smoothDamp(current, target, velocity, smoothTime, deltaTime) {
      const omega = 2 / smoothTime;
      const x = omega * deltaTime;
      const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
      const change = current - target;
      const temp = (velocity + omega * change) * deltaTime;
      velocity = (velocity - omega * temp) * exp;
      let output = target + (change + temp) * exp;
      return { value: output, velocity: velocity };
    }
    
    // === AUDIO ===
    function initAudio() {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    
    function playSound(freq, duration, type = 'sine', volume = 0.3) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.setValueAtTime(volume, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + duration);
    }
    
    function playBounce() {
      playSound(400, 0.1, 'sine', 0.2);
    }
    
    function playBreak() {
      playSound(200 + Math.random() * 100, 0.15, 'square', 0.15);
    }
    
    function playInvincible() {
      playSound(800, 0.3, 'sawtooth', 0.2);
      setTimeout(() => playSound(1000, 0.2, 'sawtooth', 0.15), 100);
    }
    
    function playLose() {
      playSound(200, 0.3, 'sawtooth', 0.3);
      setTimeout(() => playSound(150, 0.4, 'sawtooth', 0.25), 150);
    }
    
    function playWin() {
      playSound(523, 0.15, 'sine', 0.3);
      setTimeout(() => playSound(659, 0.15, 'sine', 0.3), 100);
      setTimeout(() => playSound(784, 0.3, 'sine', 0.3), 200);
    }

    
    // === THREE.JS SETUP ===
    function initScene() {
      scene = new THREE.Scene();
      
      // Gradient background (like Unity skybox)
      const bgCanvas = document.createElement('canvas');
      bgCanvas.width = 2;
      bgCanvas.height = 512;
      const bgCtx = bgCanvas.getContext('2d');
      const gradient = bgCtx.createLinearGradient(0, 0, 0, 512);
      gradient.addColorStop(0, '#667eea');
      gradient.addColorStop(0.5, '#764ba2');
      gradient.addColorStop(1, '#3d2963');
      bgCtx.fillStyle = gradient;
      bgCtx.fillRect(0, 0, 2, 512);
      scene.background = new THREE.CanvasTexture(bgCanvas);
      
      // Camera
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.insertBefore(renderer.domElement, document.body.firstChild);
      
      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      
      const directional = new THREE.DirectionalLight(0xffffff, 0.8);
      directional.position.set(5, 20, 10);
      directional.castShadow = true;
      directional.shadow.mapSize.width = 2048;
      directional.shadow.mapSize.height = 2048;
      directional.shadow.camera.near = 0.5;
      directional.shadow.camera.far = 100;
      directional.shadow.camera.left = -20;
      directional.shadow.camera.right = 20;
      directional.shadow.camera.top = 20;
      directional.shadow.camera.bottom = -20;
      scene.add(directional);
      
      // Central pole
      const poleGeo = new THREE.CylinderGeometry(CONFIG.platformHoleRadius - 0.05, CONFIG.platformHoleRadius - 0.05, 300, 32);
      const poleMat = new THREE.MeshStandardMaterial({ color: 0x2d3436, metalness: 0.7, roughness: 0.3 });
      const pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.y = -100;
      pole.receiveShadow = true;
      scene.add(pole);
    }
    
    // === BALL ===
    function createBall() {
      const geo = new THREE.SphereGeometry(CONFIG.ballRadius, 32, 32);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.1,
        roughness: 0.3,
        emissive: 0x000000,
        emissiveIntensity: 0
      });
      ball = new THREE.Mesh(geo, mat);
      ball.castShadow = true;
      scene.add(ball);
    }
    
    // === PLATFORM GENERATION (replicating PlatformGenerator.cs) ===
    function createPlatformSegment(innerRadius, outerRadius, startAngle, endAngle, height, color, isDanger) {
      const shape = new THREE.Shape();
      const segments = 12;
      
      // Inner arc start
      shape.moveTo(Math.cos(startAngle) * innerRadius, Math.sin(startAngle) * innerRadius);
      
      // Line to outer
      shape.lineTo(Math.cos(startAngle) * outerRadius, Math.sin(startAngle) * outerRadius);
      
      // Outer arc
      for (let i = 1; i <= segments; i++) {
        const angle = startAngle + (endAngle - startAngle) * (i / segments);
        shape.lineTo(Math.cos(angle) * outerRadius, Math.sin(angle) * outerRadius);
      }
      
      // Line to inner
      shape.lineTo(Math.cos(endAngle) * innerRadius, Math.sin(endAngle) * innerRadius);
      
      // Inner arc (reverse)
      for (let i = segments - 1; i >= 0; i--) {
        const angle = startAngle + (endAngle - startAngle) * (i / segments);
        shape.lineTo(Math.cos(angle) * innerRadius, Math.sin(angle) * innerRadius);
      }
      
      const extrudeSettings = {
        depth: height,
        bevelEnabled: true,
        bevelThickness: 0.05,
        bevelSize: 0.05,
        bevelSegments: 2
      };
      
      const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geo.rotateX(Math.PI / 2);
      geo.translate(0, -height / 2, 0);
      
      const mat = new THREE.MeshStandardMaterial({
        color: isDanger ? 0x1a1a1a : color,
        metalness: isDanger ? 0.8 : 0.1,
        roughness: isDanger ? 0.2 : 0.5
      });
      
      const mesh = new THREE.Mesh(geo, mat);
      mesh.castShadow = true;
      mesh.receiveShadow = true;
      mesh.userData.isDanger = isDanger;
      mesh.userData.color = color;
      
      return mesh;
    }
    
    function createPlatform(y, rotation, color, dangerPartsCount) {
      const group = new THREE.Group();
      group.userData = {
        y: y,
        destroyed: false,
        segments: []
      };
      
      const segmentCount = CONFIG.platformSegments;
      const segmentAngle = (Math.PI * 2) / segmentCount;
      const gap = 0.08;
      
      // Randomly assign danger parts (like Unity's Platform.Init)
      const dangerIndices = new Set();
      let assigned = 0;
      for (let i = 0; i < segmentCount && assigned < dangerPartsCount; i++) {
        if (Math.random() < 0.9) { // 90% chance like Unity
          dangerIndices.add(i);
          assigned++;
        }
      }
      
      for (let i = 0; i < segmentCount; i++) {
        const startAngle = i * segmentAngle + gap;
        const endAngle = (i + 1) * segmentAngle - gap;
        const isDanger = dangerIndices.has(i);
        
        const segment = createPlatformSegment(
          CONFIG.platformHoleRadius,
          CONFIG.platformRadius,
          startAngle,
          endAngle,
          CONFIG.platformHeight,
          color,
          isDanger
        );
        
        segment.userData.segmentIndex = i;
        segment.userData.centerAngle = (startAngle + endAngle) / 2;
        group.add(segment);
        group.userData.segments.push(segment);
      }
      
      group.position.y = y;
      group.rotation.y = rotation;
      scene.add(group);
      
      return group;
    }
    
    function createFinishPlatform(y) {
      const geo = new THREE.CylinderGeometry(CONFIG.platformRadius + 0.5, CONFIG.platformRadius + 0.5, 1, 32);
      const mat = new THREE.MeshStandardMaterial({
        color: 0xFFD700,
        metalness: 0.6,
        roughness: 0.3,
        emissive: 0xFFD700,
        emissiveIntensity: 0.2
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.position.y = y;
      mesh.receiveShadow = true;
      mesh.userData = { isFinish: true, y: y };
      scene.add(mesh);
      return mesh;
    }
    
    function generatePlatforms() {
      // Clear existing
      platforms.forEach(p => scene.remove(p));
      platforms = [];
      
      let rotation = 0;
      const rotationIncrement = CONFIG.platformOffsetAngle * (Math.PI / 180);
      
      let samePlatformCount = 0;
      let samePlatformMax = CONFIG.minSamePlatforms + Math.floor(Math.random() * (CONFIG.maxSamePlatforms - CONFIG.minSamePlatforms));
      let currentDangerParts = Math.floor(Math.random() * (CONFIG.platformSegments - CONFIG.platformSafeParts));
      
      const startY = 5;
      
      for (let i = 0; i < CONFIG.platformCount; i++) {
        const y = startY - (i * CONFIG.platformOffsetHeight);
        const gradientT = i / CONFIG.platformCount;
        const colorRGB = getGradientColor(gradientT);
        const color = colorToHex(colorRGB);
        
        // Same platform grouping (like Unity's ConfigurePlatforms)
        samePlatformCount++;
        if (samePlatformCount > samePlatformMax) {
          samePlatformCount = 0;
          samePlatformMax = CONFIG.minSamePlatforms + Math.floor(Math.random() * (CONFIG.maxSamePlatforms - CONFIG.minSamePlatforms));
          currentDangerParts = Math.floor(Math.random() * (CONFIG.platformSegments - CONFIG.platformSafeParts));
        }
        
        const platform = createPlatform(y, rotation, color, currentDangerParts);
        platform.userData.colorRGB = colorRGB;
        platforms.push(platform);
        
        rotation += rotationIncrement;
      }
      
      // Finish platform
      const finishY = startY - (CONFIG.platformCount * CONFIG.platformOffsetHeight) - 2;
      const finish = createFinishPlatform(finishY);
      platforms.push(finish);
    }
    
    // === PLATFORM DESTRUCTION (replicating Platform.cs) ===
    function destroyPlatform(platform) {
      if (platform.userData.destroyed) return;
      platform.userData.destroyed = true;
      
      playBreak();
      
      const segments = platform.userData.segments || [];
      const platformY = platform.userData.y;
      const platformRotation = platform.rotation.y;
      
      segments.forEach((segment, i) => {
        // Calculate world position of segment center
        const angle = segment.userData.centerAngle + platformRotation;
        const radius = (CONFIG.platformHoleRadius + CONFIG.platformRadius) / 2;
        const worldX = Math.cos(angle) * radius;
        const worldZ = Math.sin(angle) * radius;
        
        // Clone segment for particle
        const piece = segment.clone();
        piece.position.set(worldX, platformY, worldZ);
        scene.add(piece);
        
        // Calculate throw direction (like Unity's GetThrowDirection)
        const throwX = (worldX <= 0 ? -1 : 1) * CONFIG.platformThrowOffsetX;
        const throwY = platformY + CONFIG.platformThrowOffsetY;
        const throwZ = worldZ;
        
        particles.push({
          mesh: piece,
          type: 'platformPiece',
          startPos: new THREE.Vector3(worldX, platformY, worldZ),
          targetPos: new THREE.Vector3(throwX, throwY, throwZ),
          startRot: new THREE.Euler(0, 0, 0),
          targetRot: new THREE.Euler(
            Math.random() * Math.PI * 4,
            Math.random() * Math.PI * 4,
            Math.random() * Math.PI * 4
          ),
          progress: 0,
          duration: CONFIG.platformDestroyDuration
        });
      });
      
      scene.remove(platform);
      
      // Update score and progress
      score++;
      platformsDestroyed++;
      scoreDisplay.textContent = score;
      progressFill.style.height = (platformsDestroyed / CONFIG.platformCount * 100) + '%';
      
      // Invincibility build-up
      handleInvincibilityBuildUp();
      
      // Notify app
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'score', score }));
      }
    }

    
    // === INVINCIBILITY SYSTEM (replicating BallInvincibility.cs) ===
    function handleInvincibilityBuildUp() {
      if (isInvincible) return;
      
      platformsForInvincibility++;
      
      if (platformsForInvincibility < CONFIG.platformsToEnableIndicator) return;
      
      invincibilityBuildUp += CONFIG.secondsPerPlatform;
      
      if (invincibilityBuildUp >= CONFIG.secondsToEnableInvincible) {
        enableInvincibility();
      } else {
        const fillAmount = invincibilityBuildUp / CONFIG.secondsToEnableInvincible;
        invincibilityFill.style.height = (fillAmount * 100) + '%';
        invincibilityIndicator.classList.add('visible');
      }
    }
    
    function enableInvincibility() {
      isInvincible = true;
      invincibilityTimer = CONFIG.invincibleSeconds;
      invincibilityIndicator.classList.add('visible', 'invincible');
      invincibilityFill.style.height = '100%';
      
      // Ball fire effect
      ball.material.emissive.setHex(0xFF4400);
      ball.material.emissiveIntensity = 0.6;
      
      playInvincible();
    }
    
    function disableInvincibility() {
      isInvincible = false;
      invincibilityTimer = 0;
      invincibilityBuildUp = 0;
      platformsForInvincibility = 0;
      
      invincibilityIndicator.classList.remove('visible', 'invincible');
      invincibilityFill.style.height = '0%';
      
      ball.material.emissive.setHex(0x000000);
      ball.material.emissiveIntensity = 0;
    }
    
    function updateInvincibility(deltaTime) {
      if (isInvincible) {
        invincibilityTimer -= deltaTime;
        const fillAmount = invincibilityTimer / CONFIG.invincibleSeconds;
        invincibilityFill.style.height = Math.max(0, fillAmount * 100) + '%';
        
        if (invincibilityTimer <= 0) {
          disableInvincibility();
        }
      } else if (!isPressed && invincibilityBuildUp > 0) {
        // Timer countdown when not pressing (like Unity's TryResumeCountdown)
        invincibilityBuildUp -= deltaTime;
        if (invincibilityBuildUp <= 0) {
          invincibilityBuildUp = 0;
          platformsForInvincibility = 0;
          invincibilityIndicator.classList.remove('visible');
          invincibilityFill.style.height = '0%';
        } else {
          const fillAmount = invincibilityBuildUp / CONFIG.secondsToEnableInvincible;
          invincibilityFill.style.height = (fillAmount * 100) + '%';
        }
      }
    }
    
    // === FOOTPRINTS (replicating Footprint.cs) ===
    function leaveFootprint(x, y, z, color) {
      const geo = new THREE.CircleGeometry(0.35, 16);
      const mat = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.6,
        side: THREE.DoubleSide
      });
      const footprint = new THREE.Mesh(geo, mat);
      footprint.rotation.x = -Math.PI / 2;
      footprint.position.set(x, y + 0.01, z);
      scene.add(footprint);
      
      footprints.push({
        mesh: footprint,
        life: 1
      });
    }
    
    // === TRAIL EFFECT (replicating BallVFX trail) ===
    function spawnTrailParticle() {
      if (isInvincible) {
        // Fire particles when invincible
        const geo = new THREE.SphereGeometry(0.15 + Math.random() * 0.1, 8, 8);
        const mat = new THREE.MeshBasicMaterial({
          color: Math.random() > 0.5 ? 0xFF6600 : 0xFFCC00,
          transparent: true,
          opacity: 0.8
        });
        const particle = new THREE.Mesh(geo, mat);
        particle.position.copy(ball.position);
        particle.position.x += (Math.random() - 0.5) * 0.3;
        particle.position.z += (Math.random() - 0.5) * 0.3;
        scene.add(particle);
        
        trailParticles.push({
          mesh: particle,
          life: 1,
          decay: 0.08
        });
      } else {
        // Normal white trail
        const geo = new THREE.SphereGeometry(0.12, 8, 8);
        const mat = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.5
        });
        const particle = new THREE.Mesh(geo, mat);
        particle.position.copy(ball.position);
        particle.position.y += 0.2;
        scene.add(particle);
        
        trailParticles.push({
          mesh: particle,
          life: 1,
          decay: 0.05
        });
      }
    }
    
    // === COLLISION DETECTION (replicating BallCollisionHandler.cs) ===
    function checkCollisions() {
      const ballBottom = ball.position.y - CONFIG.ballRadius;
      
      for (const platform of platforms) {
        if (platform.userData.destroyed) continue;
        
        const platY = platform.userData.y;
        const platTop = platY + CONFIG.platformHeight / 2;
        const platBottom = platY - CONFIG.platformHeight / 2;
        
        // Check if ball is at platform height
        if (ballBottom <= platTop && ballBottom >= platBottom - 0.1 && ballVelocity < 0) {
          
          // Finish platform
          if (platform.userData.isFinish) {
            winGame();
            return;
          }
          
          // Check if over the hole
          const distFromCenter = Math.sqrt(ball.position.x * ball.position.x + ball.position.z * ball.position.z);
          if (distFromCenter < CONFIG.platformHoleRadius) {
            continue; // Ball goes through hole
          }
          
          if (isPressed) {
            // Smashing - check for danger parts
            const segments = platform.userData.segments || [];
            let hitDanger = false;
            
            // Find which segment ball is over
            const ballAngle = Math.atan2(ball.position.z, ball.position.x);
            const platformRotation = platform.rotation.y;
            
            for (const segment of segments) {
              if (!segment.userData.isDanger) continue;
              
              let segAngle = segment.userData.centerAngle + platformRotation;
              // Normalize
              while (segAngle > Math.PI) segAngle -= Math.PI * 2;
              while (segAngle < -Math.PI) segAngle += Math.PI * 2;
              
              let diff = Math.abs(ballAngle - segAngle);
              if (diff > Math.PI) diff = Math.PI * 2 - diff;
              
              const segmentArc = Math.PI / CONFIG.platformSegments;
              if (diff < segmentArc && distFromCenter > CONFIG.platformHoleRadius && distFromCenter < CONFIG.platformRadius) {
                hitDanger = true;
                break;
              }
            }
            
            if (hitDanger && !isInvincible) {
              loseGame();
              return;
            }
            
            destroyPlatform(platform);
          } else {
            // Bouncing
            ballVelocity = CONFIG.jumpPower;
            ball.position.y = platTop + CONFIG.ballRadius;
            
            // Leave footprint
            const color = platform.userData.colorRGB ? colorToHex(platform.userData.colorRGB) : 0xffffff;
            leaveFootprint(ball.position.x, platTop, ball.position.z, color);
            
            playBounce();
          }
          
          return;
        }
      }
    }
    
    // === CAMERA (replicating CameraMover.cs) ===
    function updateCamera(deltaTime) {
      const targetPos = ball.position.y + CONFIG.cameraTrackOffset.y;
      
      // Only track when pressed and going down (like Unity)
      const canTrack = isPressed && targetPos < cameraTargetY;
      if (canTrack) {
        cameraTargetY = targetPos;
      }
      
      // Smooth damp (like Unity's Vector3.SmoothDamp)
      const result = smoothDamp(camera.position.y, cameraTargetY, cameraVelocity, CONFIG.cameraTrackDelay, deltaTime);
      camera.position.y = result.value;
      cameraVelocity = result.velocity;
      
      camera.position.x = CONFIG.cameraTrackOffset.x;
      camera.position.z = -CONFIG.cameraTrackOffset.z;
      camera.lookAt(0, ball.position.y - 2, 0);
    }
    
    // === GAME LOOP ===
    let lastTime = 0;
    let trailTimer = 0;
    
    function update(currentTime) {
      requestAnimationFrame(update);
      
      const deltaTime = Math.min((currentTime - lastTime) / 1000, 0.1);
      lastTime = currentTime;
      
      if (gameState !== 'playing') {
        renderer.render(scene, camera);
        return;
      }
      
      // Ball physics (replicating BallMover.cs)
      if (isPressed) {
        // Move down at constant speed (like Unity's MoveCoroutine)
        ball.position.y -= CONFIG.moveSpeed * deltaTime;
        ballVelocity = -CONFIG.moveSpeed;
        
        // Trail particles
        trailTimer += deltaTime;
        if (trailTimer > 0.03) {
          spawnTrailParticle();
          trailTimer = 0;
        }
      } else {
        // Gravity
        ballVelocity -= CONFIG.gravity * deltaTime;
        ball.position.y += ballVelocity * deltaTime;
      }
      
      // Ball squash/stretch
      const speed = Math.abs(ballVelocity);
      const stretch = 1 + speed * 0.02;
      ball.scale.set(1 / Math.sqrt(stretch), stretch, 1 / Math.sqrt(stretch));
      
      // Collision
      checkCollisions();
      
      // Camera
      updateCamera(deltaTime);
      
      // Invincibility
      updateInvincibility(deltaTime);
      
      // Update particles (platform pieces)
      particles = particles.filter(p => {
        p.progress += deltaTime / p.duration;
        
        if (p.progress >= 1) {
          scene.remove(p.mesh);
          return false;
        }
        
        // Lerp position
        p.mesh.position.lerpVectors(p.startPos, p.targetPos, p.progress);
        
        // Lerp rotation
        p.mesh.rotation.x = lerp(p.startRot.x, p.targetRot.x, p.progress);
        p.mesh.rotation.y = lerp(p.startRot.y, p.targetRot.y, p.progress);
        p.mesh.rotation.z = lerp(p.startRot.z, p.targetRot.z, p.progress);
        
        // Fade out
        if (p.progress > 0.7) {
          const fade = 1 - (p.progress - 0.7) / 0.3;
          p.mesh.scale.setScalar(fade);
        }
        
        return true;
      });
      
      // Update trail particles
      trailParticles = trailParticles.filter(p => {
        p.life -= p.decay;
        if (p.life <= 0) {
          scene.remove(p.mesh);
          return false;
        }
        p.mesh.scale.setScalar(p.life);
        p.mesh.material.opacity = p.life * 0.8;
        return true;
      });
      
      // Update footprints
      footprints = footprints.filter(f => {
        f.life -= deltaTime * 0.3;
        if (f.life <= 0) {
          scene.remove(f.mesh);
          return false;
        }
        f.mesh.material.opacity = f.life * 0.6;
        return true;
      });
      
      // Fall off check
      if (ball.position.y < -100) {
        loseGame();
      }
      
      renderer.render(scene, camera);
    }
    
    // === GAME STATE MANAGEMENT ===
    function startGame() {
      if (!audioCtx) initAudio();
      
      gameState = 'playing';
      startScreen.classList.add('hidden');
      endScreen.style.display = 'none';
      
      resetGame();
    }
    
    function resetGame() {
      // Clear particles
      particles.forEach(p => scene.remove(p.mesh));
      particles = [];
      trailParticles.forEach(p => scene.remove(p.mesh));
      trailParticles = [];
      footprints.forEach(f => scene.remove(f.mesh));
      footprints = [];
      
      // Reset state
      score = 0;
      platformsDestroyed = 0;
      ballVelocity = 0;
      isInvincible = false;
      invincibilityTimer = 0;
      invincibilityBuildUp = 0;
      platformsForInvincibility = 0;
      
      // Reset UI
      scoreDisplay.textContent = '0';
      progressFill.style.height = '0%';
      invincibilityIndicator.classList.remove('visible', 'invincible');
      invincibilityFill.style.height = '0%';
      
      // Reset ball
      ball.position.set(0, 8, 0);
      ball.scale.set(1, 1, 1);
      ball.material.emissive.setHex(0x000000);
      ball.material.emissiveIntensity = 0;
      ball.visible = true;
      
      // Reset camera
      const startY = 8 + CONFIG.cameraStartOffset.y;
      camera.position.set(CONFIG.cameraStartOffset.x, startY, -CONFIG.cameraStartOffset.z);
      cameraTargetY = startY;
      cameraVelocity = 0;
      
      // Generate platforms
      generatePlatforms();
      
      gameState = 'playing';
    }
    
    function loseGame() {
      gameState = 'ended';
      playLose();
      
      // Hide ball
      ball.visible = false;
      
      // Explosion particles
      for (let i = 0; i < 30; i++) {
        const geo = new THREE.SphereGeometry(0.1, 8, 8);
        const mat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
        const p = new THREE.Mesh(geo, mat);
        p.position.copy(ball.position);
        scene.add(p);
        
        const angle = Math.random() * Math.PI * 2;
        const speed = 3 + Math.random() * 5;
        const upSpeed = Math.random() * 5;
        
        particles.push({
          mesh: p,
          type: 'explosion',
          startPos: p.position.clone(),
          targetPos: new THREE.Vector3(
            p.position.x + Math.cos(angle) * speed,
            p.position.y + upSpeed,
            p.position.z + Math.sin(angle) * speed
          ),
          startRot: new THREE.Euler(0, 0, 0),
          targetRot: new THREE.Euler(0, 0, 0),
          progress: 0,
          duration: 0.8
        });
      }
      
      // Update best score
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('stackball_best', bestScore.toString());
      }
      
      // Show end screen
      endTitle.textContent = 'GAME OVER';
      finalScoreEl.textContent = score;
      bestScoreEl.textContent = 'BEST: ' + bestScore;
      endScreen.style.display = 'flex';
      
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'gameOver', score, won: false }));
      }
    }
    
    function winGame() {
      gameState = 'ended';
      playWin();
      
      score += 10; // Bonus
      
      if (score > bestScore) {
        bestScore = score;
        localStorage.setItem('stackball_best', bestScore.toString());
      }
      
      endTitle.textContent = 'ðŸŽ‰ LEVEL COMPLETE!';
      finalScoreEl.textContent = score;
      bestScoreEl.textContent = 'BEST: ' + bestScore;
      endScreen.style.display = 'flex';
      
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'gameOver', score, won: true }));
      }
    }
    
    // === INPUT HANDLING (replicating Input.cs) ===
    function onPointerDown(e) {
      e.preventDefault();
      
      if (gameState === 'start') {
        startGame();
        return;
      }
      
      if (gameState === 'ended') {
        resetGame();
        return;
      }
      
      isPressed = true;
    }
    
    function onPointerUp(e) {
      isPressed = false;
    }
    
    // === INITIALIZATION ===
    function init() {
      initScene();
      createBall();
      generatePlatforms();
      
      // Position camera
      const startY = 8 + CONFIG.cameraStartOffset.y;
      camera.position.set(CONFIG.cameraStartOffset.x, startY, -CONFIG.cameraStartOffset.z);
      cameraTargetY = startY;
      camera.lookAt(0, 5, 0);
      
      // Input events
      document.addEventListener('mousedown', onPointerDown);
      document.addEventListener('mouseup', onPointerUp);
      document.addEventListener('touchstart', onPointerDown, { passive: false });
      document.addEventListener('touchend', onPointerUp);
      
      // Resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // Start render loop
      requestAnimationFrame(update);
    }
    
    init();
  </script>
</body>
</html>
