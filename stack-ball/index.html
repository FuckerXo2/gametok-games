<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Stack Ball</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      overflow: hidden; 
      touch-action: none;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #1a1a2e;
    }
    #ui {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 20px;
      padding-top: 50px;
      z-index: 10;
      pointer-events: none;
    }
    #score {
      font-size: 72px;
      font-weight: 900;
      color: white;
      text-align: center;
      text-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    #combo {
      position: absolute;
      top: 35%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 90px;
      font-weight: 900;
      color: #FF6B35;
      text-shadow: 0 0 60px #FF6B35, 0 0 120px #FF6B35;
      opacity: 0;
      pointer-events: none;
      z-index: 20;
    }
    #combo.show {
      animation: comboPop 0.5s ease-out forwards;
    }
    @keyframes comboPop {
      0% { opacity: 1; transform: translate(-50%, -50%) scale(0.3); }
      50% { transform: translate(-50%, -50%) scale(1.3); }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1) translateY(-50px); }
    }
    #startScreen {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
      color: white;
      z-index: 30;
    }
    #startScreen h1 { 
      font-size: 52px; 
      font-weight: 900;
      margin-bottom: 10px;
      text-shadow: 0 4px 30px rgba(0,0,0,0.3);
    }
    #startScreen p { 
      font-size: 18px; 
      opacity: 0.9; 
      margin-bottom: 60px;
    }
    #startScreen .tap { 
      font-size: 20px; 
      padding: 20px 70px;
      background: white;
      border-radius: 50px;
      font-weight: 800;
      color: #764ba2;
      box-shadow: 0 15px 50px rgba(0,0,0,0.3);
      animation: bounce 2s infinite;
    }
    @keyframes bounce { 
      0%, 100% { transform: translateY(0); } 
      50% { transform: translateY(-15px); } 
    }
    #gameOver {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.9);
      color: white;
      z-index: 30;
    }
    #gameOver h2 { 
      font-size: 32px; 
      margin-bottom: 15px;
      font-weight: 700;
    }
    #gameOver .score { 
      font-size: 100px; 
      font-weight: 900;
      margin-bottom: 10px;
    }
    #gameOver .best {
      font-size: 18px;
      opacity: 0.6;
      margin-bottom: 60px;
    }
    #gameOver .tap { 
      font-size: 20px;
      padding: 20px 70px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-radius: 50px;
      font-weight: 800;
      color: white;
      box-shadow: 0 15px 50px rgba(102,126,234,0.5);
    }
    /* Progress bar on right side */
    #progress {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      width: 6px;
      height: 200px;
      background: rgba(255,255,255,0.2);
      border-radius: 3px;
      z-index: 10;
    }
    #progressBar {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: white;
      border-radius: 3px;
      transition: height 0.3s;
      height: 0%;
    }
    /* Invincibility indicator bar on left side */
    #invincibilityBar {
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      width: 8px;
      height: 150px;
      background: rgba(255,255,255,0.15);
      border-radius: 4px;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.3s;
    }
    #invincibilityBar.visible {
      opacity: 1;
    }
    #invincibilityFill {
      position: absolute;
      bottom: 0;
      width: 100%;
      background: linear-gradient(to top, #4ECDC4, #44E5E7);
      border-radius: 4px;
      transition: height 0.15s, background 0.3s;
      height: 0%;
    }
    #invincibilityBar.invincible #invincibilityFill {
      background: linear-gradient(to top, #FF6B35, #FFD93D);
      box-shadow: 0 0 20px #FF6B35;
    }
    #fireOverlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: radial-gradient(circle at 50% 60%, rgba(255,100,0,0.25) 0%, transparent 50%);
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 5;
    }
    #fireOverlay.active {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div id="score">0</div>
  </div>
  <div id="combo"></div>
  <div id="progress"><div id="progressBar"></div></div>
  <div id="invincibilityBar"><div id="invincibilityFill"></div></div>
  <div id="fireOverlay"></div>
  <div id="startScreen">
    <h1>STACK BALL</h1>
    <p>Hold to smash â€¢ Release to bounce</p>
    <div class="tap">HOLD TO PLAY</div>
  </div>
  <div id="gameOver">
    <h2>GAME OVER</h2>
    <div class="score" id="finalScore">0</div>
    <div class="best" id="finalBest">BEST: 0</div>
    <div class="tap">TAP TO RETRY</div>
  </div>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    // DOM Elements
    const scoreEl = document.getElementById('score');
    const comboEl = document.getElementById('combo');
    const startScreen = document.getElementById('startScreen');
    const gameOverScreen = document.getElementById('gameOver');
    const finalScoreEl = document.getElementById('finalScore');
    const finalBestEl = document.getElementById('finalBest');
    const progressBar = document.getElementById('progressBar');
    const invincibilityBar = document.getElementById('invincibilityBar');
    const invincibilityFill = document.getElementById('invincibilityFill');
    const fireOverlay = document.getElementById('fireOverlay');
    
    // Three.js objects
    let scene, camera, renderer, ball, pole;
    let platforms = [], particles = [], trails = [], footprints = [];
    
    // Game state
    let score = 0, highScore = 0, combo = 0;
    let gameStarted = false, gameOver = false, isHolding = false;
    let ballVelocity = 0, ballY = 15, cameraY = 20;
    let totalPlatforms = 35, platformsSmashed = 0;
    let screenShake = 0;
    let towerRotation = 0;
    
    // Invincibility system (like Unity version)
    let invincible = false;
    let invincibilityTimer = 0;
    let invincibilityBuildUp = 0;
    const PLATFORMS_TO_SHOW_BAR = 10;
    const SECONDS_PER_PLATFORM = 0.15;
    const SECONDS_TO_ENABLE = 4;
    const INVINCIBLE_DURATION = 3;
    let platformsDestroyedForInvincibility = 0;
    
    // Gradient colors for platforms (like Unity version)
    const GRADIENT_COLORS = [
      { pos: 0.0, color: new THREE.Color(0xFF6B6B) },
      { pos: 0.2, color: new THREE.Color(0xFFE66D) },
      { pos: 0.4, color: new THREE.Color(0x4ECDC4) },
      { pos: 0.6, color: new THREE.Color(0x95E1D3) },
      { pos: 0.8, color: new THREE.Color(0xBB8FCE) },
      { pos: 1.0, color: new THREE.Color(0xFF8B94) }
    ];
    
    const BLACK = 0x1C1C1E;
    
    // Physics constants
    const PLATFORM_GAP = 0.4;
    const PLATFORM_RADIUS = 3.2;
    const PLATFORM_HEIGHT = 0.7;
    const PLATFORM_HOLE = 0.5;
    const GRAVITY = 0.012;
    const BOUNCE_FORCE = 0.28;
    const SMASH_SPEED = 0.5;
    const ROTATION_ANGLE = 2; // degrees per platform
    
    function getGradientColor(t) {
      t = Math.max(0, Math.min(1, t));
      for (let i = 0; i < GRADIENT_COLORS.length - 1; i++) {
        if (t >= GRADIENT_COLORS[i].pos && t <= GRADIENT_COLORS[i + 1].pos) {
          const localT = (t - GRADIENT_COLORS[i].pos) / (GRADIENT_COLORS[i + 1].pos - GRADIENT_COLORS[i].pos);
          const c = new THREE.Color();
          c.lerpColors(GRADIENT_COLORS[i].color, GRADIENT_COLORS[i + 1].color, localT);
          return c;
        }
      }
      return GRADIENT_COLORS[GRADIENT_COLORS.length - 1].color;
    }
    
    function init() {
      scene = new THREE.Scene();
      
      // Gradient background
      const canvas = document.createElement('canvas');
      canvas.width = 2; canvas.height = 512;
      const ctx = canvas.getContext('2d');
      const gradient = ctx.createLinearGradient(0, 0, 0, 512);
      gradient.addColorStop(0, '#667eea');
      gradient.addColorStop(0.5, '#764ba2');
      gradient.addColorStop(1, '#4a3f6b');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 2, 512);
      scene.background = new THREE.CanvasTexture(canvas);
      
      // Camera setup (top-down angled view like real Stack Ball)
      camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 20, 8.3);
      camera.lookAt(0, 8, 0);
      
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);
      
      // Lighting
      const ambient = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambient);
      
      const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
      mainLight.position.set(5, 30, 10);
      mainLight.castShadow = true;
      mainLight.shadow.mapSize.width = 2048;
      mainLight.shadow.mapSize.height = 2048;
      mainLight.shadow.camera.near = 0.5;
      mainLight.shadow.camera.far = 100;
      mainLight.shadow.camera.left = -15;
      mainLight.shadow.camera.right = 15;
      mainLight.shadow.camera.top = 15;
      mainLight.shadow.camera.bottom = -15;
      scene.add(mainLight);
      
      const rimLight = new THREE.DirectionalLight(0xffffff, 0.3);
      rimLight.position.set(-5, 10, -10);
      scene.add(rimLight);
      
      // Pole (center cylinder)
      const poleGeo = new THREE.CylinderGeometry(PLATFORM_HOLE - 0.05, PLATFORM_HOLE - 0.05, 200, 32);
      const poleMat = new THREE.MeshStandardMaterial({ 
        color: 0x2d3436,
        metalness: 0.8,
        roughness: 0.2
      });
      pole = new THREE.Mesh(poleGeo, poleMat);
      pole.position.y = -80;
      pole.castShadow = true;
      pole.receiveShadow = true;
      scene.add(pole);
      
      // Ball
      const ballGeo = new THREE.SphereGeometry(0.5, 32, 32);
      const ballMat = new THREE.MeshStandardMaterial({ 
        color: 0xffffff,
        metalness: 0.1,
        roughness: 0.2,
        emissive: 0x000000,
        emissiveIntensity: 0
      });
      ball = new THREE.Mesh(ballGeo, ballMat);
      ball.castShadow = true;
      ball.position.y = ballY;
      scene.add(ball);
      
      generatePlatforms();
      
      window.addEventListener('resize', onResize);
      document.addEventListener('touchstart', onPress);
      document.addEventListener('touchend', onRelease);
      document.addEventListener('mousedown', onPress);
      document.addEventListener('mouseup', onRelease);
      
      animate();
    }
    
    function generatePlatforms() {
      let currentRotation = 0;
      let samePlatformCount = 0;
      let samePlatformMax = 5 + Math.floor(Math.random() * 35);
      let currentDangerParts = Math.floor(Math.random() * 6);
      
      for (let i = 0; i < totalPlatforms; i++) {
        const y = 10 - (i * PLATFORM_GAP);
        const gradientT = i / totalPlatforms;
        const color = getGradientColor(gradientT);
        
        samePlatformCount++;
        if (samePlatformCount > samePlatformMax) {
          samePlatformCount = 0;
          samePlatformMax = 5 + Math.floor(Math.random() * 35);
          currentDangerParts = Math.floor(Math.random() * 6);
        }
        
        currentRotation += ROTATION_ANGLE * (Math.PI / 180);
        const platform = createPlatform(y, color, currentDangerParts, currentRotation);
        platforms.push(platform);
      }
      
      // Win platform at bottom
      const winY = 10 - (totalPlatforms * PLATFORM_GAP) - 2;
      const winGeo = new THREE.CylinderGeometry(PLATFORM_RADIUS + 1, PLATFORM_RADIUS + 1, 1.5, 32);
      const winMat = new THREE.MeshStandardMaterial({ 
        color: 0xFFD700, 
        metalness: 0.7, 
        roughness: 0.2,
        emissive: 0xFFD700,
        emissiveIntensity: 0.3
      });
      const win = new THREE.Mesh(winGeo, winMat);
      win.position.y = winY;
      win.receiveShadow = true;
      win.userData.isWin = true;
      scene.add(win);
      platforms.push({ mesh: win, isBlack: false, y: winY, isWin: true, segments: [] });
    }
    
    function createPlatform(y, color, dangerPartsCount, rotation) {
      const group = new THREE.Group();
      group.userData = { y, smashed: false };
      
      const segments = 8;
      const segmentAngle = (Math.PI * 2) / segments;
      const gap = 0.06;
      
      const segmentData = [];
      let dangerAssigned = 0;
      
      // Randomly assign danger parts
      const dangerIndices = new Set();
      while (dangerIndices.size < dangerPartsCount && dangerIndices.size < segments - 2) {
        const idx = Math.floor(Math.random() * segments);
        if (Math.random() < 0.9) dangerIndices.add(idx);
      }
      
      for (let i = 0; i < segments; i++) {
        const isDanger = dangerIndices.has(i);
        const startAngle = i * segmentAngle + gap;
        const endAngle = (i + 1) * segmentAngle - gap;
        
        const shape = new THREE.Shape();
        const inner = PLATFORM_HOLE;
        const outer = PLATFORM_RADIUS;
        
        shape.moveTo(Math.cos(startAngle) * inner, Math.sin(startAngle) * inner);
        shape.lineTo(Math.cos(startAngle) * outer, Math.sin(startAngle) * outer);
        
        const arcPoints = 8;
        for (let j = 1; j <= arcPoints; j++) {
          const a = startAngle + (endAngle - startAngle) * (j / arcPoints);
          shape.lineTo(Math.cos(a) * outer, Math.sin(a) * outer);
        }
        
        shape.lineTo(Math.cos(endAngle) * inner, Math.sin(endAngle) * inner);
        
        for (let j = arcPoints - 1; j >= 0; j--) {
          const a = startAngle + (endAngle - startAngle) * (j / arcPoints);
          shape.lineTo(Math.cos(a) * inner, Math.sin(a) * inner);
        }
        
        const extrudeSettings = { 
          depth: PLATFORM_HEIGHT, 
          bevelEnabled: true,
          bevelThickness: 0.08,
          bevelSize: 0.08,
          bevelSegments: 2
        };
        
        const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        geo.rotateX(Math.PI / 2);
        geo.translate(0, -PLATFORM_HEIGHT/2, 0);
        
        const segColor = isDanger ? BLACK : color.getHex();
        const mat = new THREE.MeshStandardMaterial({ 
          color: segColor,
          metalness: isDanger ? 0.9 : 0.1,
          roughness: isDanger ? 0.1 : 0.4,
        });
        
        const segment = new THREE.Mesh(geo, mat);
        segment.castShadow = true;
        segment.receiveShadow = true;
        segment.userData.isDanger = isDanger;
        segment.userData.color = segColor;
        segment.userData.angle = (startAngle + endAngle) / 2;
        group.add(segment);
        
        segmentData.push({ mesh: segment, isDanger, angle: segment.userData.angle });
      }
      
      group.position.y = y;
      group.rotation.y = rotation;
      scene.add(group);
      
      const hasAnyDanger = dangerPartsCount > 0;
      return { mesh: group, isBlack: hasAnyDanger, y, segments: segmentData, rotation };
    }

    
    function smashPlatform(platform) {
      if (platform.mesh.userData.smashed) return;
      platform.mesh.userData.smashed = true;
      
      screenShake = invincible ? 18 : 10;
      
      // Explode segments outward (like Unity version - fly to sides)
      platform.mesh.children.forEach((segment, i) => {
        const angle = segment.userData.angle + platform.mesh.rotation.y;
        const piece = segment.clone();
        
        // Position in world space
        piece.position.x = Math.cos(angle) * (PLATFORM_RADIUS / 2);
        piece.position.y = platform.y;
        piece.position.z = Math.sin(angle) * (PLATFORM_RADIUS / 2);
        
        // Throw direction (outward and up, like Unity's ThrowPointOffsetX/Y)
        const throwX = Math.cos(angle) * 8;
        const throwY = platform.y + 13;
        const throwZ = Math.sin(angle) * 8;
        
        piece.userData.targetPos = new THREE.Vector3(throwX, throwY, throwZ);
        piece.userData.startPos = piece.position.clone();
        piece.userData.targetRot = new THREE.Euler(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        piece.userData.startRot = piece.rotation.clone();
        piece.userData.life = 1;
        piece.userData.duration = 1;
        
        scene.add(piece);
        particles.push({ mesh: piece, type: 'chunk' });
      });
      
      // Spawn small particles
      const particleCount = invincible ? 30 : 18;
      const baseColor = platform.mesh.children[0]?.userData.color || 0xffffff;
      
      for (let i = 0; i < particleCount; i++) {
        const size = 0.06 + Math.random() * 0.1;
        const geo = new THREE.SphereGeometry(size, 6, 6);
        const mat = new THREE.MeshBasicMaterial({ 
          color: invincible ? (Math.random() > 0.5 ? 0xFF6B35 : 0xFFD93D) : baseColor
        });
        const p = new THREE.Mesh(geo, mat);
        
        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * PLATFORM_RADIUS;
        p.position.set(
          Math.cos(angle) * radius,
          platform.y,
          Math.sin(angle) * radius
        );
        p.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.35,
          Math.random() * 0.25 + 0.1,
          (Math.random() - 0.5) * 0.35
        );
        p.userData.life = 1;
        scene.add(p);
        particles.push({ mesh: p, type: 'particle' });
      }
      
      scene.remove(platform.mesh);
      
      score++;
      platformsSmashed++;
      scoreEl.textContent = score;
      progressBar.style.height = (platformsSmashed / totalPlatforms * 100) + '%';
      
      // Invincibility build-up (like Unity version)
      if (!invincible) {
        platformsDestroyedForInvincibility++;
        
        if (platformsDestroyedForInvincibility >= PLATFORMS_TO_SHOW_BAR) {
          invincibilityBuildUp += SECONDS_PER_PLATFORM;
          
          if (invincibilityBuildUp >= SECONDS_TO_ENABLE) {
            enableInvincibility();
          } else {
            const fillPercent = (invincibilityBuildUp / SECONDS_TO_ENABLE) * 100;
            invincibilityFill.style.height = fillPercent + '%';
            invincibilityBar.classList.add('visible');
          }
        }
      }
      
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'score', score }));
      }
    }
    
    function enableInvincibility() {
      invincible = true;
      invincibilityTimer = INVINCIBLE_DURATION;
      invincibilityBar.classList.add('visible', 'invincible');
      invincibilityFill.style.height = '100%';
      fireOverlay.classList.add('active');
      ball.material.emissive.setHex(0xFF6B35);
      ball.material.emissiveIntensity = 0.6;
      
      // Hide trail during invincibility
      trails.forEach(t => scene.remove(t));
      trails = [];
    }
    
    function disableInvincibility() {
      invincible = false;
      invincibilityTimer = 0;
      invincibilityBuildUp = 0;
      platformsDestroyedForInvincibility = 0;
      invincibilityBar.classList.remove('visible', 'invincible');
      invincibilityFill.style.height = '0%';
      fireOverlay.classList.remove('active');
      ball.material.emissive.setHex(0x000000);
      ball.material.emissiveIntensity = 0;
    }
    
    function showCombo(num) {
      comboEl.textContent = 'x' + num;
      comboEl.className = '';
      void comboEl.offsetWidth;
      comboEl.classList.add('show');
    }
    
    // Trail effect (only when NOT invincible)
    function spawnTrail() {
      if (invincible) return;
      
      const geo = new THREE.SphereGeometry(0.25, 8, 8);
      const mat = new THREE.MeshBasicMaterial({ 
        color: 0xffffff,
        transparent: true,
        opacity: 0.6
      });
      const t = new THREE.Mesh(geo, mat);
      t.position.copy(ball.position);
      t.position.y += 0.3;
      t.userData.life = 1;
      scene.add(t);
      trails.push(t);
    }
    
    // Fire trail (only when invincible)
    function spawnFireTrail() {
      if (!invincible) return;
      
      const geo = new THREE.SphereGeometry(0.3 + Math.random() * 0.2, 8, 8);
      const mat = new THREE.MeshBasicMaterial({ 
        color: Math.random() > 0.5 ? 0xFF6B35 : 0xFFD93D,
        transparent: true,
        opacity: 0.8
      });
      const t = new THREE.Mesh(geo, mat);
      t.position.copy(ball.position);
      t.position.x += (Math.random() - 0.5) * 0.4;
      t.position.z += (Math.random() - 0.5) * 0.4;
      t.userData.life = 1;
      scene.add(t);
      trails.push(t);
    }
    
    // Footprint when bouncing (like Unity version)
    function leaveFootprint(platformY, color) {
      const geo = new THREE.CircleGeometry(0.4, 16);
      const mat = new THREE.MeshBasicMaterial({ 
        color: color,
        transparent: true,
        opacity: 0.5,
        side: THREE.DoubleSide
      });
      const fp = new THREE.Mesh(geo, mat);
      fp.rotation.x = -Math.PI / 2;
      fp.position.set(ball.position.x, platformY + PLATFORM_HEIGHT/2 + 0.01, ball.position.z);
      fp.userData.life = 1;
      scene.add(fp);
      footprints.push(fp);
    }
    
    let lastTrailTime = 0;
    let lastFireTrailTime = 0;
    let lastTime = performance.now();
    
    function update() {
      if (!gameStarted || gameOver) return;
      
      const now = performance.now();
      const deltaTime = (now - lastTime) / 1000;
      lastTime = now;
      
      // Invincibility timer countdown
      if (invincible) {
        invincibilityTimer -= deltaTime;
        const fillPercent = (invincibilityTimer / INVINCIBLE_DURATION) * 100;
        invincibilityFill.style.height = Math.max(0, fillPercent) + '%';
        
        if (invincibilityTimer <= 0) {
          disableInvincibility();
        }
      } else if (!isHolding && invincibilityBuildUp > 0) {
        // Decay invincibility build-up when not pressing (like Unity)
        invincibilityBuildUp -= deltaTime * 0.5;
        if (invincibilityBuildUp <= 0) {
          invincibilityBuildUp = 0;
          platformsDestroyedForInvincibility = 0;
          invincibilityBar.classList.remove('visible');
        } else {
          const fillPercent = (invincibilityBuildUp / SECONDS_TO_ENABLE) * 100;
          invincibilityFill.style.height = fillPercent + '%';
        }
      }
      
      // Ball physics
      if (isHolding) {
        ballVelocity = -SMASH_SPEED;
        
        // Trail effects
        if (invincible) {
          if (now - lastFireTrailTime > 30) {
            spawnFireTrail();
            lastFireTrailTime = now;
          }
        } else {
          if (now - lastTrailTime > 50) {
            spawnTrail();
            lastTrailTime = now;
          }
        }
      } else {
        ballVelocity -= GRAVITY;
      }
      
      ballY += ballVelocity;
      ball.position.y = ballY;
      
      // Ball squash & stretch
      const stretch = 1 + Math.abs(ballVelocity) * 1.2;
      ball.scale.set(1/Math.sqrt(stretch), stretch, 1/Math.sqrt(stretch));
      
      // Ball rotation
      ball.rotation.x += ballVelocity * 0.6;
      ball.rotation.z += 0.015;
      
      // Tower rotation (slow auto-rotate)
      towerRotation += 0.002;
      platforms.forEach(p => {
        if (p.mesh && !p.mesh.userData.smashed && !p.isWin) {
          p.mesh.rotation.y = p.rotation + towerRotation;
        }
      });
      
      // Platform collision
      for (const platform of platforms) {
        if (platform.mesh.userData?.smashed) continue;
        
        const platY = platform.y;
        const ballBottom = ballY - 0.5 * ball.scale.y;
        
        if (ballBottom <= platY + PLATFORM_HEIGHT/2 && 
            ballBottom >= platY - PLATFORM_HEIGHT/2 - 0.25 && 
            ballVelocity < 0) {
          
          if (platform.isWin) {
            winGame();
            return;
          }
          
          // Check if hitting a danger segment
          let hitDanger = false;
          if (platform.segments) {
            const ballAngle = Math.atan2(ball.position.z, ball.position.x);
            const platformRotation = platform.mesh.rotation.y;
            
            for (const seg of platform.segments) {
              if (seg.isDanger) {
                let segAngle = seg.angle + platformRotation;
                // Normalize angles
                while (segAngle > Math.PI) segAngle -= Math.PI * 2;
                while (segAngle < -Math.PI) segAngle += Math.PI * 2;
                
                let diff = Math.abs(ballAngle - segAngle);
                if (diff > Math.PI) diff = Math.PI * 2 - diff;
                
                // Check if ball is over this segment
                const ballRadius = Math.sqrt(ball.position.x * ball.position.x + ball.position.z * ball.position.z);
                if (ballRadius > PLATFORM_HOLE && ballRadius < PLATFORM_RADIUS && diff < Math.PI / 8) {
                  hitDanger = true;
                  break;
                }
              }
            }
          }
          
          if (hitDanger && !invincible) {
            if (isHolding) {
              endGame();
              return;
            }
          }
          
          if (isHolding) {
            smashPlatform(platform);
            combo++;
            if (combo > 1) showCombo(combo);
          } else {
            // Bounce
            ballVelocity = BOUNCE_FORCE;
            ballY = platY + PLATFORM_HEIGHT/2 + 0.5;
            combo = 0;
            screenShake = 4;
            
            // Leave footprint
            const color = platform.mesh.children[0]?.userData.color || 0xffffff;
            leaveFootprint(platY, color);
          }
          break;
        }
      }
      
      // Camera follow - ONLY when pressing (like Unity CameraMover)
      const targetCamY = ballY + 12;
      if (isHolding && targetCamY < cameraY) {
        cameraY += (targetCamY - cameraY) * 0.08;
      }
      
      // Apply screen shake
      let shakeX = 0, shakeY = 0;
      if (screenShake > 0) {
        shakeX = (Math.random() - 0.5) * screenShake * 0.025;
        shakeY = (Math.random() - 0.5) * screenShake * 0.025;
        screenShake *= 0.88;
        if (screenShake < 0.5) screenShake = 0;
      }
      
      camera.position.set(shakeX, cameraY + shakeY, 8.3);
      camera.lookAt(0, ballY - 4, 0);
      
      // Update chunk particles (platform pieces flying outward)
      particles = particles.filter(p => {
        const m = p.mesh;
        
        if (p.type === 'chunk') {
          m.userData.life -= 0.015;
          const t = 1 - m.userData.life;
          
          // Lerp position
          m.position.lerpVectors(m.userData.startPos, m.userData.targetPos, t);
          
          // Lerp rotation
          m.rotation.x = THREE.MathUtils.lerp(m.userData.startRot.x, m.userData.targetRot.x, t);
          m.rotation.y = THREE.MathUtils.lerp(m.userData.startRot.y, m.userData.targetRot.y, t);
          m.rotation.z = THREE.MathUtils.lerp(m.userData.startRot.z, m.userData.targetRot.z, t);
          
          // Fade out near end
          if (m.userData.life < 0.3) {
            m.scale.setScalar(m.userData.life / 0.3);
          }
        } else {
          m.position.add(m.userData.velocity);
          m.userData.velocity.y -= 0.015;
          m.userData.life -= 0.035;
          m.scale.setScalar(m.userData.life * 0.8);
        }
        
        if (m.userData.life <= 0) {
          scene.remove(m);
          return false;
        }
        return true;
      });
      
      // Update trails
      trails = trails.filter(t => {
        t.userData.life -= invincible ? 0.1 : 0.06;
        t.scale.setScalar(t.userData.life);
        t.material.opacity = t.userData.life * (invincible ? 0.8 : 0.6);
        if (t.userData.life <= 0) {
          scene.remove(t);
          return false;
        }
        return true;
      });
      
      // Update footprints
      footprints = footprints.filter(fp => {
        fp.userData.life -= 0.008;
        fp.material.opacity = fp.userData.life * 0.5;
        if (fp.userData.life <= 0) {
          scene.remove(fp);
          return false;
        }
        return true;
      });
      
      // Fall off
      if (ballY < -100) endGame();
    }
    
    function winGame() {
      gameOver = true;
      score += 20;
      scoreEl.textContent = score;
      
      if (score > highScore) highScore = score;
      finalScoreEl.textContent = score;
      finalBestEl.textContent = 'BEST: ' + highScore;
      gameOverScreen.querySelector('h2').textContent = 'ðŸŽ‰ LEVEL COMPLETE!';
      gameOverScreen.style.display = 'flex';
      
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'gameOver', score, won: true }));
      }
    }
    
    function endGame() {
      gameOver = true;
      disableInvincibility();
      
      if (score > highScore) highScore = score;
      finalScoreEl.textContent = score;
      finalBestEl.textContent = 'BEST: ' + highScore;
      gameOverScreen.querySelector('h2').textContent = 'GAME OVER';
      gameOverScreen.style.display = 'flex';
      
      // Ball explosion
      for (let i = 0; i < 45; i++) {
        const geo = new THREE.SphereGeometry(0.08 + Math.random() * 0.12, 6, 6);
        const mat = new THREE.MeshBasicMaterial({ color: 0xff4444 });
        const p = new THREE.Mesh(geo, mat);
        p.position.copy(ball.position);
        p.userData.velocity = new THREE.Vector3(
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5,
          (Math.random() - 0.5) * 0.5
        );
        p.userData.life = 1;
        scene.add(p);
        particles.push({ mesh: p, type: 'particle' });
      }
      
      ball.visible = false;
      screenShake = 25;
      
      if (window.ReactNativeWebView) {
        window.ReactNativeWebView.postMessage(JSON.stringify({ type: 'gameOver', score, won: false }));
      }
    }
    
    function resetGame() {
      platforms.forEach(p => { if (p.mesh) scene.remove(p.mesh); });
      platforms = [];
      particles.forEach(p => scene.remove(p.mesh));
      particles = [];
      trails.forEach(t => scene.remove(t));
      trails = [];
      footprints.forEach(fp => scene.remove(fp));
      footprints = [];
      
      score = 0; combo = 0; ballY = 15; ballVelocity = 0; cameraY = 20;
      platformsSmashed = 0; gameOver = false; screenShake = 0;
      towerRotation = 0;
      
      // Reset invincibility
      invincible = false;
      invincibilityTimer = 0;
      invincibilityBuildUp = 0;
      platformsDestroyedForInvincibility = 0;
      invincibilityBar.classList.remove('visible', 'invincible');
      invincibilityFill.style.height = '0%';
      fireOverlay.classList.remove('active');
      
      scoreEl.textContent = '0';
      progressBar.style.height = '0%';
      gameOverScreen.style.display = 'none';
      
      ball.visible = true;
      ball.position.y = ballY;
      ball.scale.set(1, 1, 1);
      ball.material.emissive.setHex(0x000000);
      ball.material.emissiveIntensity = 0;
      camera.position.set(0, cameraY, 8.3);
      
      lastTime = performance.now();
      generatePlatforms();
    }
    
    function animate() {
      requestAnimationFrame(animate);
      update();
      renderer.render(scene, camera);
    }
    
    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    function onPress(e) {
      e.preventDefault();
      if (!gameStarted) {
        gameStarted = true;
        startScreen.style.display = 'none';
        lastTime = performance.now();
        return;
      }
      if (gameOver) {
        resetGame();
        return;
      }
      isHolding = true;
    }
    
    function onRelease() {
      isHolding = false;
    }
    
    init();
  </script>
</body>
</html>
